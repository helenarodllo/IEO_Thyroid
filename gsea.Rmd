---
title: "GSEA"
author: "Lydia Fortea"
date: "8/6/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# GSEA

```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(sva)
library(corpcor)

opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

thca <- readRDS(file.path("results", "thca.filt4.rds"))
dge <- readRDS(file.path("results", "dge.filt4.rds"))
DEgenes <- readRDS("DEgenes1.rds")
```

```{r}
library(org.Hs.eg.db)
library(GSEABase)
#Separate up and down-regulated genes for genesets
tumor <- DEgenes[DEgenes$LogFC > 0,]
normal <- DEgenes[DEgenes$LogFC < 0,]
DE_t <- GeneSet(EntrezIdentifier("org.Hs.eg.db"), geneIds = rownames(tumor), setName = "up tumor genes")
DE_n <- GeneSet(EntrezIdentifier("org.Hs.eg.db"), geneIds = rownames(normal), setName = "up normal genes")
details(DE_t)
details(DE_n)
DEsym_t <- mapIdentifiers(DE_t, SymbolIdentifier())
DEsym_n <- mapIdentifiers(DE_n, SymbolIdentifier())
DEsym_t
DEsym_n
diff <- setdiff(DEsym_t,DEsym_n)
typeDEgenes <- DEsym_t | DEsym_n
```

We can load an object for the Broad Gene Set C2, to add it into the GeneSetCollection object for the analysis.

```{r}
library(GSVAdata)
data(c2BroadSets)
c2BroadSets <- c2BroadSets[c(grep("^KEGG", names(c2BroadSets)),
grep("^REACTOME", names(c2BroadSets)), grep("^BIOCARTA", names(c2BroadSets)))]
gsc <- GeneSetCollection(c(c2BroadSets, DE_t, DE_n))
gsc
```

Now we have all dataset, we can perform the simple GSEA analysis

1. Map the identifiers from gene set to the identifiers of the analyzed data

```{r}
gsc <- mapIdentifiers(gsc, AnnoOrEntrezIdentifier(metadata(thca)$annotation))
gsc
Im <- incidence(gsc)
dim(Im)
```

2. Discard genes that are not part from our data

```{r}
Im <- Im[, colnames(Im) %in% rownames(thca)]
dim(Im)
dim(thca)
thca <- thca[colnames(Im), ]
dim(thca)
dge <- dge[colnames(Im), ]
dim(dge)
```

3. Star GSEA without calling any gene DE

```{r}
library(limma)
library(sva)
mod <- model.matrix(~type, data = colData(thca))
mod0 <- model.matrix(~1, colData(thca))
#sv <- sva(assays(thca)$logCPM, mod = mod, mod0 = mod0)
mod <- cbind(mod, sv$sv)
colnames(mod) <- c(colnames(mod)[1:2], paste0("SV", 1:sv$n))
sample_id <- substr(colnames(thca), 9, 12)
colData(thca)$sample_id <- factor(sample_id)
#corfit <- duplicateCorrelation(assays(thca)$logCPM, mod, block = thca$sample_id)
fit <- lmFit(assays(thca)$logCPM, mod, block = thca$sample_id, correlation = corfit$consensus)
fit <- eBayes(fit, trend = TRUE)
tt <- topTable(fit, coef = 2, n = Inf)
```

To have robustness, we need to set a minimum size cut-off, as 5 genes

```{r}
Im <- Im[rowSums(Im) >= 5, ]
dim(Im)
tGSgenes <- tt[match(colnames(Im), rownames(tt)), "t"]
length(tGSgenes)
zS <- sqrt(rowSums(Im)) * (as.vector(Im %*% tGSgenes)/rowSums(Im))
length(zS)
head(zS)
rnkGS <- sort(abs(zS), decreasing = TRUE)
```

Function to produce a scatter plot

```{r}
plotGS <- function(se, gs, pheno, ...) {
l <- levels(colData(se)[, pheno])
idxSamples1 <- colData(se)[, pheno] == l[1]
idxSamples2 <- colData(se)[, pheno] == l[2]
exps1 <- rowMeans(assays(se)$logCPM[gs, idxSamples1])
exps2 <- rowMeans(assays(se)$logCPM[gs, idxSamples2])
rng <- range(c(exps1, exps2))
plot(exps1, exps2, pch = 21, col = "black", bg = "black", xlim = rng, ylim = rng,
xlab = l[1], ylab = l[2], ...)
abline(a = 0, b = 1, lwd = 2, col = "red")
}
```

We plot mean expression values per gene

```{r}
genesGS1 <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
genesGS2 <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
par(mfrow = c(1, 2), mar = c(4, 5, 3, 4))
plotGS(thca, genesGS1, "type", main = names(rnkGS)[1], cex.lab = 2, las = 1)
plotGS(thca, genesGS2, "type", main = names(rnkGS)[2], cex.lab = 2, las = 1)
```


```{r}
pv <- pmin(pnorm(zS), 1 - pnorm(zS))
sum(pv < 0.05)
pvadj <- p.adjust(pv, method = "fdr")
DEgs <- names(pvadj)[which(pvadj < 0.01)]
length(DEgs)
head(DEgs, n = 3)
```

We need to take into account the overlap between geneset.

```{r}
library(GSVA)
gsov <- computeGeneSetsOverlap(gsc[DEgs], rownames(thca))
trimask <- upper.tri(gsov)
rnkOv <- data.frame(gs1 = row(gsov)[trimask], gs2 = col(gsov)[trimask], ov = gsov[trimask])
rnkOv <- rnkOv[order(rnkOv$ov, decreasing = TRUE), ]
rnkOv$gs1 <- rownames(gsov)[rnkOv$gs1]
rnkOv$gs2 <- rownames(gsov)[rnkOv$gs2]
sum(rnkOv$ov == 1) ## how many pairs of gene sets are identical?
sum(rnkOv$ov < 0.01)
```

```{r}
library(Category)
xS <- applyByCategory(tGSgenes, Im, function(x) (sum((x - mean(x))^2) - (length(x) - 1))/(2 *(length(x) - 1)))
rnkGS <- sort(abs(xS), decreasing = TRUE)
pv <- pmin(pnorm(xS), 1 - pnorm(xS))
pvadj <- p.adjust(pv)
DEgsByScale <- names(pvadj)[which(pvadj < 0.01)]
length(DEgsByScale)
length(intersect(DEgs, DEgsByScale))
setdiff(DEgsByScale, DEgs)
```

Plots

```{r}
topgs1genes <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
topgs2genes <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
topgs3genes <- colnames(Im)[which(Im[names(rnkGS)[3], ] == 1)]
par(mfrow = c(1, 3))
plotGS(thca, topgs1genes, "type", main = names(rnkGS)[1], cex.lab = 2, las = 1)
plotGS(thca, topgs2genes, "type", main = names(rnkGS)[2], cex.lab = 2, las = 1)
plotGS(thca, topgs3genes, "type", main = names(rnkGS)[3], cex.lab = 2, las = 1)
```
