---
title: "FunctEnrich"
author: "Lydia Fortea"
date: "8/6/2018"
output: pdf_document
---

```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(sva)
library(corpcor)

opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

thca <- readRDS(file.path("results", "thca.filt4.rds"))
dge <- readRDS(file.path("results", "dge.filt4.rds"))
thca.pair <- readRDS("thca_paired_design.rds")
dge.pair <- readRDS("dge_paired_design .rds")
DEgenes <- readRDS("DEgenes_paired.rds")
```

# Functional Enrichment

## Gene Ontology Analysis

A popular kind of analysis which corresponds to applying the one-tailed Fisher's exact test to every gene set in the GO database.

We need first to download the annotated genes for humans, and declare the Gene Universe and the sudied DEgenes dataset.

```{r, warning=FALSE, message=FALSE}
library(org.Hs.eg.db)
allHumanGO <- select(org.Hs.eg.db, columns = "GO", key = keys(org.Hs.eg.db, keytype = "SYMBOL"), keytype = "SYMBOL")
geneUniverse <- rownames(thca.paired)
DEgenes <- readRDS("DEgenes_paired.rds")
```

Analysis:

```{r, message=FALSE, warning=FALSE}
#parameter with all object
library(GOstats)
params <- new("GOHyperGParams", geneIds=rownames(DEgenes), universeGeneIds=geneUniverse, annotation="org.Hs.eg.db", ontology="BP", pvalueCutoff=0.01, testDirection="over")

#run the analysis taking into account parent and child terms
conditional(params) <- TRUE
hgOver <- hyperGTest(params)

#store and visualize results
htmlReport(hgOver, file = "gocondtests.html")
goresults <- summary(hgOver)
head(goresults)
```


GO terms involving a few genes (e.g., < 3) in their size (m) and in their enrichment by DE genes (k) are likely to be less reliable than those that involve many genes. Likewise, large GO terms may provide little insight. That way, we need to filter results as follows:

```{r}
goresults <- goresults[goresults$Size >= 3 & goresults$Size <=300, ]
goresults <- goresults[order(goresults$OddsRatio, decreasing=TRUE), ]
head(goresults)
dim(goresults)
```

Extract genes that enrich each GO term

```{r, message=FALSE, warning=FALSE}
geneIDs <- geneIdsByCategory(hgOver)[goresults$GOBPID]
geneSYMs <- sapply(geneIDs, function(id) select(org.Hs.eg.db, columns = "SYMBOL", key = id,
keytype = "ENTREZID")$SYMBOL)
geneSYMs <- sapply(geneSYMs, paste, collapse = ", ")
goresults <- cbind(goresults, Genes = geneSYMs)
rownames(goresults) <- 1:nrow(goresults)
```

Export results

```{r}
library(xtable)
xtab <- xtable(goresults, align = "l|c|r|r|r|r|r|p{3cm}|p{3cm}|")
print(xtab, file = "goresults.html", type = "html")
```

## GSEA 

Classical functional enrichment analyses based on over-representation tests such as the one-tailed Fisher's exact test have the problem that require a sizeable list of DE genes.

```{r}
library(org.Hs.eg.db)
library(GSEABase)
DE <- GeneSet(EntrezIdentifier("org.Hs.eg.db"), geneIds = rownames(DEgenes), setName = "DE genes paired design")
details(DE)
```

We can load an object for the Broad Gene Set C2, to add it into the GeneSetCollection object for the analysis.

```{r}
library(GSVAdata)
data(c2BroadSets)
c2BroadSets <- c2BroadSets[c(grep("^KEGG", names(c2BroadSets)),
grep("^REACTOME", names(c2BroadSets)))]
gsc <- GeneSetCollection(c(c2BroadSets, DE))
gsc
```

Now we have all dataset, we can perform the simple GSEA analysis

1. Map the identifiers from gene set to the identifiers of the analyzed data

```{r}
gsc <- mapIdentifiers(gsc, AnnoOrEntrezIdentifier(metadata(thca.pair)$annotation))
gsc
Im <- incidence(gsc)
dim(Im)
```

2. Discard genes that are not part from our data

```{r}
Im <- Im[, colnames(Im) %in% rownames(thca.pair)]
dim(Im)
dim(thca.pair)
thca.pair <- thca.pair[colnames(Im), ]
dim(thca.pair)
dge.pair <- dge.pair[colnames(Im), ]
dim(dge.pair)
```

3. Start GSEA without calling any gene DE

repeated measures with adjustment for unkown covariates variables

```{r}
library(limma)
library(sva)
mod <- model.matrix(~type, data = colData(thca.pair))
mod0 <- model.matrix(~1, colData(thca.pair))
sv <- sva(assays(thca.pair)$logCPM, mod = mod, mod0 = mod0)
mod <- cbind(mod, sv$sv)
colnames(mod) <- c(colnames(mod)[1:2], paste0("SV", 1:sv$n))
#sample_id <- substr(colnames(thca.pair), 9, 12)
#colData(thca.pair)$sample_id <- factor(sample_id)
corfit <- duplicateCorrelation(assays(thca.pair)$logCPM, mod, block = thca.pair$sample_id)
fit <- lmFit(assays(thca.pair)$logCPM, mod, block = thca.pair$sample_id, correlation = corfit$consensus)
fit <- eBayes(fit, trend = TRUE)
tt <- topTable(fit, coef = 2, n = Inf)
```

To have robustness, we need to set a minimum size cut-off, as 10 genes

```{r}
Im <- Im[rowSums(Im) >= 10, ]
dim(Im)
tGSgenes <- tt[match(colnames(Im), rownames(tt)), "t"]
length(tGSgenes)
zS <- sqrt(rowSums(Im)) * (as.vector(Im %*% tGSgenes)/rowSums(Im))
length(zS)
head(zS)
rnkGS <- sort(abs(zS), decreasing = TRUE)
head(rnkGS)
```

Function to produce a scatter plot

```{r}
plotGS <- function(se, gs, pheno, ...) {
l <- levels(colData(se)[, pheno])
idxSamples1 <- colData(se)[, pheno] == l[1]
idxSamples2 <- colData(se)[, pheno] == l[2]
exps1 <- rowMeans(assays(se)$logCPM[gs, idxSamples1])
exps2 <- rowMeans(assays(se)$logCPM[gs, idxSamples2])
rng <- range(c(exps1, exps2))
plot(exps1, exps2, pch = 21, col = "black", bg = "black", xlim = rng, ylim = rng,
xlab = l[1], ylab = l[2], ...)
abline(a = 0, b = 1, lwd = 2, col = "red")
}
```

We plot mean expression values per gene

```{r}
par(mfrow=c(5,4), mar=c(2, 2, 2, 2))
for (i in 1:40) {
  genesGS <- colnames(Im)[which(Im[names(rnkGS)[i], ] == 1)]
  plotGS(thca.pair, genesGS, "type", main = names(rnkGS)[i], cex.lab = 1, las = 1, cex.main=0.5)
}
```


```{r}
genesGS1 <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
genesGS2 <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
par(mfrow = c(1, 2), mar = c(4, 5, 3, 4))
plotGS(thca, genesGS1, "type", main = names(rnkGS)[1], cex.lab = 2, las = 1)
plotGS(thca, genesGS2, "type", main = names(rnkGS)[2], cex.lab = 2, las = 1)
```


```{r}
pv <- pmin(pnorm(zS), 1 - pnorm(zS))
sum(pv < 0.01)
pvadj <- p.adjust(pv, method = "fdr")
DEgs <- names(pvadj)[which(pvadj < 0.01)]
length(DEgs)
head(DEgs, n = 10)
```

We need to take into account the overlap between geneset.

```{r}
library(GSVA)
gsov <- computeGeneSetsOverlap(gsc[DEgs], rownames(thca))
trimask <- upper.tri(gsov)
rnkOv <- data.frame(gs1 = row(gsov)[trimask], gs2 = col(gsov)[trimask], ov = gsov[trimask])
rnkOv <- rnkOv[order(rnkOv$ov, decreasing = TRUE), ]
rnkOv$gs1 <- rownames(gsov)[rnkOv$gs1]
rnkOv$gs2 <- rownames(gsov)[rnkOv$gs2]
sum(rnkOv$ov == 1) ## how many pairs of gene sets are identical?
sum(rnkOv$ov < 0.01) ## how many pairs of gene sets share less than 5% of the genes?
```

Apply Chi-2 to detect mean shift in gene expression.

```{r}
library(Category)
xS <- applyByCategory(tGSgenes, Im, function(x) (sum((x - mean(x))^2) - (length(x) - 1))/(2 *(length(x) - 1)))
rnkGS <- sort(abs(xS), decreasing = TRUE)
pv <- pmin(pnorm(xS), 1 - pnorm(xS))
pvadj <- p.adjust(pv, method="fdr")
DEgsByScale <- names(pvadj)[which(pvadj < 0.01)]
length(DEgsByScale)
length(intersect(DEgs, DEgsByScale))
inter <- intersect(DEgs, DEgsByScale)
```

save intersection to compare:

```{r}
write.csv(inter, file= "DE_path_paired.csv")
```

Plots

```{r}
par(mfrow=c(5,4), mar=c(2, 2, 2, 2))
for (i in 1:40) {
  topgsgenes <- colnames(Im)[which(Im[names(rnkGS)[i], ] == 1)]
  plotGS(thca.pair, topgsgenes, "type", main = names(rnkGS)[i], cex.lab = 1, las = 1)
}
```


