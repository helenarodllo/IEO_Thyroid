---
title: "Thyroides carcinoma"
author: "Lydia Fortea, Helena Rodriguez, Julia Mir"
date: "25/4/2018"
output: html_document
---
---
output:
  BiocStyle::html_document
---


```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)

opts_chunk$set(cache=TRUE,
               cache.path="cache/QA",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")
```

# Quality assessment

## Data import

We start importing the raw table of counts.


```{r, message=FALSE}
library(SummarizedExperiment)

thca <- readRDS("seTHCA.rds")
thca
```

Explore the column (phenotypic) data, which in this case corresponds to clinical
variables, and their corresponding metadata.

```{r}
dim(colData(thca))
colData(thca)[1:5, 1:5]
mcols(colData(thca), use.names=TRUE)
metadata(thca)
```

These metadata consists of two columns of information about the clinical variables.
One called `labelDescription` contains a succint description of the variable, often
not more self-explanatory than the variable name itself, and the other called
'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This
identifier can be use in https://cdebrowser.nci.nih.gov to search for further
information about the associated clinical variable using the `Advanced search`
form and the `Public ID` attribute search.

Those data are from the "Alternative preprocessing of RNA-Sequencing data in The Cancer Genome Atlas leads to improved analysis results" project, with 20115 analyzed genes and 572 samples. 

Now, explore the row (feature) data.

```{r}
rowData(thca)
rowRanges(thca)
```

To perform quality assessment and normalization we need first to load the
[edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package and
create a `DGEList' object.

```{r, message=FALSE}
library(edgeR)

dge <- DGEList(counts=assays(thca)$counts, genes=mcols(thca))
saveRDS(dge, file.path("./", "dge.rds"))
```

Now calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation.

```{r}
assays(thca)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(thca)$logCPM[1:5, 1:5]
```

## Sequencing depth

In this part, we examine the sequencing depth in terms of total number of sequence read counts
mapped to the genome per sample. Figure \@ref(fig:libsizes) below shows the
sequencing depth per sample, also known as library sizes, in increasing order.

We first look for different types of samples: tumor and normal.

```{r libsizes, echo=FALSE, fig.cap="Library sizes in increasing order."}
ord <- order(dge$sample$lib.size/1e6)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
                xlab="Samples", col=c("red", "blue")[(thca$type[ord] == "tumor") + 1], border = NA)
legend("topleft", c("tumor", "normal"), fill=c("blue", "red"), inset=0.01)
```

- Tumor samples: 513

- Normal samples: 59

As we can observe in this plot, we have too more samples from tumor than normal one with 
similar sequence depth. This figure also reveals substantial differences in sequencing depth between 
samples and we may consider discarding those samples whose depth is substantially lower
than the rest.


**Sample Depth**

As we have seen differences of depth, we want to remove those samples with less than 40 of sequencing depth.

```{r}
sampledepth <- round(dge$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(thca), 6, 12)
sort(sampledepth)
```


Looking for the gender distribution of the samples, we observe that there are 140 samples from male, 406 samples of female and several samples without known gender. We may later analyze the differences between males and females,as we known that thyroid carcinoma affects more to women than men, we are going to remove those samples with NA value in gender.

We apply two filter: one for the sample depth and other for the gender.

```{r}
maskd <- sampledepth > 40 #sample depth filter
maskg <- !is.na(thca$gender) #gender filter
dim(thca)
thca.filt <- thca[maskd,maskg]
dge.filt <- dge[maskd,maskg]
dim(thca.filt)
```

With that filter, we have decreasing our data size in 16948 genes and 555 samples.

## Distribution of expression levels among samples

Let's look at the distribution of expression values per sample in terms of
logarithmic CPM units. Due to the large number of samples, we display tumor
and normal samples separately, and are shown in Figure \@ref(fig:distRawExp)

```{r distRawExp, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
library(geneplotter)
par(mfrow=c(1, 2))
multidensity(as.list(as.data.frame(assays(thca.filt[, thca.filt$type == "tumor"])$logCPM)),
                          xlab="log 2 CPM", legend=NULL, main="Tumor samples", las=1)
multidensity(as.list(as.data.frame(assays(thca.filt[, thca.filt$type == "normal"])$logCPM)),
                          xlab="log 2 CPM", legend=NULL, main="Normal samples", las=1)
```

From this plots, we can observe that all samples follow a similar pattern with a lot of genes very expressed and many other lowly expressed.
We can also observe few samples that deviate a little bit around -5:0 log2CPM in tumor types, but it is not very noticeable. Moreover, There is no sample with a clearly evidence of being wrong.

We also perform a box plot of the expression values per sample, to have another visual way to interpret the data, because samples can have different interquartiles range (spot locations differences).

```{r distRawExp, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Box plot of the distribution expression values across samples", message=FALSE}
boxplot(assays(thca.filt)$logCPM, col = "gray", xlab = "Samples", ylab = expression(log[2] * "CPM"), cex.axis = 1.2, cex.lab = 1.5, las = 1)
```

We can observe in that plot, that there is few samples which deviate a little bit of the average, but they are not very noticeable.
After the normalization, we have to look for those samples and observe if they are still deviate in order to remove them.
## Distribution of expression levels among genes

Let's calculate now the average expression per gene through all the samples. 
Figure \@ref(fig:exprdist) shows the distribution of those values across genes.

```{r exprdist, echo=FALSE, out.width="400px", fig.cap="Distribution of average expression level per gene."}
avgexp <- rowMeans(assays(thca.filt)$logCPM)
hist(avgexp, xlab="log2 CPM", main="", las=1, col = "blue")
abline(v=0, col="red", lwd=2)
```

We observe, that the most part of the genes have at least a log2CPM greater than 0, and we want to remove those one lowly expressed.

## Filtering of lowly-expressed genes

First, we are going to filter out genes with fewer than a given number of samples meeting a minimum log2CPM cutoff, with the following code and visualize it with an histogram.

```{r}
#explicar una miqueta
cpmcutoff <- round(10/min(dge.filt$sample$lib.size/1e+06), digits = 1)
cpmcutoff
nsamplescutoff <- min(table(thca.filt$gender))
nsamplescutoff
mask <- rowSums(cpm(dge.filt) > cpmcutoff) >= nsamplescutoff
thca.filt2 <- thca.filt[mask, ]
dge.filt2 <- dge.filt[mask, ]
dim(thca.filt2)
```

```{r}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "",
las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(thca.filt2)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topright", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

In this histogram, we observe those genes that have passed the cutoff, but the first two red columns are not very representative of the group, and as we have a lot of genes to perform the analysis, we are going to remove them with filtering genes out below a minimum average CPM (or CPM) value throughout the samples. To remove them, we need to choose a cutoff of 4 log2 CPM unit as minimum value of expression.

```{r}
mask <- avgexp > 4
dim(thca.filt2)
thca.filt3 <- thca.filt[mask, ]
dim(thca.filt3)
dge.filt3 <- dge.filt[mask, ]
dim(dge.filt3)
```

```{r}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "",
las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(thca.filt3)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topright", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

After filtering the dataset with both methods, we have finally 6654 genes to analyzed the differential expression.

Store un-normalized versions of the filtered expression data.

```{r}
saveRDS(thca.filt3, file.path("./", "thca.filt.unnorm.rds"))
saveRDS(dge.filt3, file.path("./", "dge.filt.unnorm.rds"))
```

## Normalization

We calculate now the normalization factors on the filtered expression data set.

```{r}
dge.filt3 <- calcNormFactors(dge.filt3)
head(dge.filt3$samples$norm.factors)
```

Replace the raw log2 CPM units in the corresponding assay element of the `SummarizedExperiment`
object, by the normalized ones.

```{r}
assays(thca.filt3)$logCPM <- cpm(dge.filt3, log=TRUE, normalized.lib.sizes=TRUE, prior.count=0.25)
```

Store normalized versions of the filtered expression data.

```{r}
saveRDS(thca.filt3, file.path("./", "thca.filt.rds"))
saveRDS(dge.filt3, file.path("./", "dge.filt.rds"))
```

## MA-plots

We first examine a global MA-plot, to have a general idea of the normalized data and non-normalized

```{r}
dge$samples$group <- thca$type
table(dge$samples$gorup)
dge.filt3$samples$group <- thca.filt3$type
plotSmear(dge, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
plotSmear(dge.filt3, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
```

We remove the lowly expressed genes to avoid artifacts in the posterior analysis. In the normalized plot, we observe a smother shape with less outliers. 

We examine now the MA-plots of the normalized expression profiles for each tumor and normal samle sparately. We look first to
the tumor samples in Figure \@ref(fig:maPlotsTumor).

```{r maPlotsTumor, fig.height=36, fig.width=6, dpi=100, echo=FALSE, fig.cap="MA-plots of the tumor samples."}
par(mfrow=c(22, 3), mar=c(4, 5, 3, 1))
setmp <- thca.filt3[, thca.filt3$type == "tumor"]
dgetmp <- dge.filt3[, thca.filt3$type == "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

We do not observe samples with major expression-level dependent biases. Let's
look now to the normal samples in Figure \@ref(fig:maPlotsNormal).

```{r maPlotsNormal, fig.height=18, fig.width=6, dpi=100, echo=FALSE, fig.cap="MA-plots of the normal samples."}
par(mfrow=c(9, 3), mar=c(4, 5, 3, 1))
setmp <- thca.filt3[, thca.filt3$type == "normal"]
dgetmp <- dge.filt3[, thca.filt3$type == "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

#Nos plantemaos elimnar samples mal distribuidos o hacer filtering between samples

We can perform a MDS plot (which is a tailored PCA) in order to visualize possibles clusters.
```{r}
plotMDS(dge.filt3, col = c("red", "blue")[as.integer(dge.filt3$samples$group)], cex = 0.7)
legend("topleft", c("normal", "tumor"), fill = c("red", "blue"), inset = 0.05, cex = 0.7)
```

We observe that there is a difference between normal and tummor samples. We have to test if this cluster is due to the type tissue or because any batch that confound our interest outcome, in order to continue with further analyses

*Tumors near red points, they don't have the same mutations, and they also are not so aggresive.*

*Normalization between Samples* LOOK
```{r}
m <- matrix(assays(thca.filt3)$counts, nrow=6654, ncol=555, byrow=TRUE)
dimnames(m) <- list(rownames(thca.filt3), colnames(thca.filt3))
#floor(colMeans(m))
#apply(m, 2, sd)
originalOrder <- apply(m, 2, order)
m <- apply(m, 2, sort)
m <- matrix(rep(floor(rowMeans(m))))
m <- sapply(1:ncol(m), function(x) m[order(originalOrder[, x]), x])
floor(colMeans(m))
apply(m, 2, sd)
```

## Batch identification

We will search now for potential surrogate of batch effect indicators. Given that each sample
names corresponds to a TCGA barcode (see https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode),
following the strategy described in http://bioinformatics.mdanderson.org/main/TCGABatchEffects:Overview
we are going to derive different elements of the TCGA barcode and examine their distribution
across samples.

```{r}
tss <- substr(colnames(thca.filt), 6, 7)
table(tss)
center <- substr(colnames(thca.filt), 27, 28)
table(center)
plate <- substr(colnames(thca.filt), 22, 25)
table(plate)
portionanalyte <- substr(colnames(thca.filt), 18, 20)
table(portionanalyte)
samplevial <- substr(colnames(thca.filt), 14, 16)
table(samplevial)
```

From this information we can make the following observations:

  * All samples were sequenced at the same center (07)

  * In this dataset, we can find six different combinations of tissue type and vial, it can be a potential batch.

  * Samples were collected across different tissue source sites (TSS).

  * Different samples were sequenced with different plates, so it can be also a potential batch.

  * Most of the samples were sequenced using one portion and analyte combinations, but there is other 5 different portion and analyte combinations

From this data we can consider as possible surrogates of batch effect indicator the tssm, plate, portionanalytic and samplevial.

*TSS*
We are going to use the TSS as surrogate of batch effect indicator. Considering our outcome
of interest as molecular changes between sample types, tumor vs. normal, we will examine now
the cross-classification of this outcome with TSS.

```{r}
table(data.frame(TYPE=thca.filt3$type, TSS=tss))
```

Observe that normal tissues from most of TSS are under-represented with respect to the tumor tissues. If TSS is a source of expression variability, this under-representation in the normal samples may lead to a potential confounding effect.

We examine now how samples group together by hierarchical clustering and multidimensional
scaling, annotating the outcome of interest and the the surrogate of batch indicator. We
calculate again log CPM values with a higher prior count to moderate extreme fold-changes
produced by low counts. The resulting dendrogram is shown in Figure \@ref(fig:sampleClustering).

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
logCPM <- cpm(dge.filt3, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(tss))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt3)
outcome <- paste(substr(colnames(thca.filt3), 9, 12), as.character(thca.filt3$type), sep="-")
names(outcome) <- colnames(thca.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(tss))), fill=sort(unique(batch)))
```

We can observe there is not evident clustering depending of the tss, so we can descard it as a 
possible batch.

In Figure \@ref(fig:mdsPlot) we show the corresponding MDS plot. Here we see more clearly that the
first source of variation separates tumor from normal samples. We can also observe that two tumor
samples, corresponding to individuals `KL-8404` and `KN-8427` are separated from the rest, just as
it happens in the hierchical clustering. A closer examination of their corresponding MA-plots also
reveals a slight dependence of expression changes on average expression. We may consider discarding
these two samples and doing the MDS plot again to have a closer look to the differences among the rest
of the samples and their relationship with TSS.

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S7: Multidimensional scaling plot of the samples."}
plotMDS(dge.filt, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(tss))),
       fill=sort(unique(batch)), inset=0.05)
```

*Plate*
```{r}
table(data.frame(TYPE=thca.filt3$type, plate=plate))
```

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S8: Hierarchical clustering of the samples by Plate."}
logCPM <- cpm(dge.filt3, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(plate))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt3)
outcome <- paste(substr(colnames(thca.filt3), 9, 12), as.character(thca.filt3$type), sep="-")
names(outcome) <- colnames(thca.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(plate))), fill=sort(unique(batch)))
```

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S9: Multidimensional scaling plot of the samples."}
plotMDS(dge.filt, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(plate))),
       fill=sort(unique(batch)), inset=0.05)
```

*PorrtionAnalyte*

```{r}
table(data.frame(TYPE=thca.filt$type, PA=portionanalyte))
```

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S10: Hierarchical clustering of the samples by Portion Analyuc."}
logCPM <- cpm(dge.filt3, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(portionanalyte))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt3)
outcome <- paste(substr(colnames(thca.filt3), 9, 12), as.character(thca.filt3$type), sep="-")
names(outcome) <- colnames(thca.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(portionanalyte))), fill=sort(unique(batch)))
```

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S11: Multidimensional scaling plot of the samples."}
plotMDS(dge.filt, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(portionanalyte))),
       fill=sort(unique(batch)), inset=0.05)
```

*Samplevial*

```{r}
table(data.frame(TYPE=thca.filt$type, SV=samplevial))
```

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S12: Hierarchical clustering of the samples by Portion Analyuc."}
logCPM <- cpm(dge.filt3, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(samplevial))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt3)
outcome <- paste(substr(colnames(thca.filt3), 9, 12), as.character(thca.filt3$type), sep="-")
names(outcome) <- colnames(thca.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(samplevial))), fill=sort(unique(batch)))
```

From this hierchical clustering plot, we can observe that there is a different cluster depending 
of the samplevial we use, so they can confounding with the interest outcome we want. For that reason,
we are going to adjust or remove this batch in order to get a non-biased results.

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S11: Multidimensional scaling plot of the samples."}
plotMDS(dge.filt, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(samplevial))),
       fill=sort(unique(batch)), inset=0.05)
```
REAL BATCH!!!
## Session information

```{r, message=FALSE}
sessionInfo()
```

