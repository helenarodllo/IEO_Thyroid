---
title: "Thyroid carcinoma"
author: "Lydia Fortea, Helena Rodríguez, Júlia Mir"
date: "25/4/2018"
output: html_document
---
---
output:
  BiocStyle::html_document
---


```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)

opts_chunk$set(cache=TRUE,
               cache.path="cache/QA",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")
```

# Visualising data

The data under study consists in counts of reads for the Thyroid carcinoma as a Summarized Experiment object \@ref(import). This dataset comes from the "Alternative preprocessing of RNA-Sequencing data in The Cancer Genome Atlas leads to improved analysis results" project, with 20115 analyzed genes and 572 samples.

The column data contains pehnotypic data, which corresponds to clinical variables and their corresponding metadata \@ref(coldata), it contains 549 columns with different information about the samples.
The metadata consists of two columns of information about the clinical variables. One called `labelDescription` contains a succint description of the variable, often
not more self-explanatory than the variable name itself, and the other called 'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This
identifier can be use in https://cdebrowser.nci.nih.gov to search for further information about the associated clinical variable using the `Advanced search`
form and the `Public ID` attribute search.

The row data contains feature data \@ref(rowdata). We can observe the characteristics of the studied genes such as their location, ranges, strand, symbol, length and CG content.

```{r import, message=FALSE}
library(SummarizedExperiment)

thca <- readRDS("../seTHCA.rds")
thca
```

```{r coldata}
dim(colData(thca))
colData(thca)[1:5, 1:5]
mcols(colData(thca), use.names=TRUE)
metadata(thca)
```

```{r rowdata}
rowData(thca)
rowRanges(thca)
```

In this supplementary material we will perform a quality assessment and normalization of the data, in order to do that, we will create a 'DGEList' object. 
In order to ease the manipulation of the data $\log_2$ CPM values of expression are calculated \@ref(logCPM).

```{r, message=FALSE}
library(edgeR)

dge <- DGEList(counts=assays(thca)$counts, genes=mcols(thca))
saveRDS(dge, file.path("./", "dge.rds"))
```

```{r logCPM}
assays(thca)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(thca)$logCPM[1:5, 1:5]
```

# Quality assessment

## Important Variables

In thyroid cancer we consider some variables more important than others as, according to bibliography, significant differences are seen in the categories of this variables related to thyroid cancer.
We want to have a first look to this categories before the analysis of the whole data. This will give us an idea of the distribution of our data and can be useful in further analysis \@ref(numvars).

```{r numvars, fig.height=20, fig.width=20}
par(mfrow=c(3, 1))
#Type
tumor <- thca[ , colData(thca)$type == "tumor"]
normal <- thca[ , colData(thca)$type == "normal"]
dim(tumor)
dim(normal)
barplot(summary(colData(thca)$type), main="Type of sample", xlab="Sample type", ylab="Total counts")
#Gender
male <- thca[ , !is.na(thca$gender) & colData(thca)$gender == "MALE"]
female <- thca[ , !is.na(thca$gender) & colData(thca)$gender == "FEMALE"]
dim(male)
dim(female)
na <- thca[ , is.na(thca$gender)]
dim(na)
barplot(summary(colData(thca)$gender), main="Patient's gender", xlab="Gender", ylab="Total counts")
#Age
barplot(summary(colData(thca)$age_at_diagnosis),main="Patient's age", xlab="Age", ylab="Total counts")
```
The last "age" column correspond to NA, but we do not remove them in this plot because we may need those samples in further analysis. 
A we can see, we have 513 tumors and 59 normal samples; or, lookig at the gender, 149 males and 406 females, with 17 samples from unknown gender. 

## Sequencing depth

In this part, we examine the sequencing depth in terms of total number of sequence read counts mapped to the genome per sample. Figure \@ref(libsizes) below shows the
sequencing depth per sample, also known as library sizes, in increasing order.

```{r libsizes, echo=FALSE, fig.cap="Fig1.Library sizes in increasing order."}
ord <- order(dge$sample$lib.size/1e6)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads", main="Sequencing depth",
                xlab="Samples", col=c("chocolate1", "skyblue")[(thca$type[ord] == "tumor") + 1], border = NA)
legend("topleft", c("tumor", "normal"), fill=c("skyblue", "chocolate1"), inset=0.01)
```

In this plot we can visually observe again that we have more samples from tumor than normal, both types have similar sequencing depth. However, the fugure also reveals substantial differences in sequencing depth between samples, this is why the discardation of those samples whose depth is substantially lower than the rest needs to be taked into consideration.

**Sample Depth**

In order to remove those samples with a lower sequencing depth value, we first calculate the sample depth \@ref(smpdepth), and then select a cutoff to remove samples.

```{r smpdepth}
sampledepth <- round(dge$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(thca), 6, 12)
sort(sampledepth)
```

Moreover, we know that this cancer has different affection depending on the gender, being women more susceptibles, so maybe we would like to compare samples regarding the gender. Samples with unknown (NA) gender will be removed in order to allow further analysis.

In conclusion, two filters are applied \@ref(maskdg):

- Remove all sample with a sample depth lower than 40.
- Remove samples without known gender.

```{r maskdg}
maskd <- sampledepth > 40 #sample depth filter
maskg <- !is.na(thca$gender) #gender filter
dim(thca)
thca.filt <- thca[,maskd&maskg]
dge.filt <- dge[,maskd&maskg]
dim(thca.filt)
```

Once the filters are applied, the dataset contains 20115 genes and 467 samples. This way, none of our samples has a low sample depth \@ref(filtlibsizes). 

```{r filtlibsizes, echo=FALSE, fig.cap="Fig1.Library sizes in increasing order."}
ord <- order(dge.filt$sample$lib.size/1e6)
barplot(dge.filt$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads", main="Sequencing depth",
                xlab="Samples", col=c("chocolate1", "skyblue")[(thca.filt$type[ord] == "tumor") + 1], border = NA)
legend("topleft", c("tumor", "normal"), fill=c("skyblue", "chocolate1"), inset=0.01)
```

## Distribution of expression levels among samples

One way to normalize RNA-seq data is an adjustment to compare across features 
in a sample, this can be performed using count per million reads (CPM). The distribution of expression values per samle in terms of logarithmic CPM units is ploted \@ref(distRawExp) separating by tumor and normal samples due to the large number of samples.
A box plot of the expression values per samples is also performed \@ref(distboxplot) in order to have another visual way to interpret the data and spot location differences. 

```{r distRawExp, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Fig2. Non-parametric density distribution of expression profiles per sample.", message=FALSE}
library(geneplotter)
par(mfrow=c(1, 2))
multidensity(as.list(as.data.frame(assays(thca.filt[, thca.filt$type == "tumor"])$logCPM)),
                          xlab="log 2 CPM", legend=NULL, main="Tumor samples", las=1)
multidensity(as.list(as.data.frame(assays(thca.filt[, thca.filt$type == "normal"])$logCPM)),
                          xlab="log 2 CPM", legend=NULL, main="Normal samples", las=1)
```

```{r distboxplot, echo=FALSE, fig.height=4, fig.width=12, out.width="800px", fig.cap="Fig3. Box plot of the distribution expression values across samples", message=FALSE}
boxplot(assays(thca.filt)$logCPM, col = "mediumseagreen", xlab = "Samples", ylab = expression(log[2] * "CPM"), cex.axis = 0.5, cex.lab = 1.5, las = 1, axes=F)
```

From this plots, it is observes that all samples follow a similar pattern with a group of highly expressed genes and another group of lowly expressed genes, following the common pattern of expression. From the box plot we can observe that there are no samples that deviate from the average interquartile range.
For all this reasons, we assume that we do not need to normalise among samples.

## Distribution of expression levels among genes

In order to identify lowly expressed genes, the average expression per gene through all samples is calculated. The distribution of thos values across genes is represented \@ref(exprdist).

```{r exprdist, echo=FALSE, out.width="400px", fig.cap="Fig4. Distribution of average expression level per gene."}
avgexp <- rowMeans(assays(thca.filt)$logCPM)
hist(avgexp, xlab="log2 CPM", main="", las=1, col = "grey")
abline(v=0, col="red", lwd=2)
```

The most part of the genes have at least a log2CPM greater than 0, and we want to remove those one lowly expressed.

## Filtering of lowly-expressed genes

We can fiter lowly-expreesed genes following two criteria:

- Filter out genes below a minimum average log2CPM throught the samples.

- Filter out genes with fewer than a given number of sample meeting a minimum log2CPM.

First, we are going to filter out genes with the second approach, and visualize it with an histogram to know if we want also to perform the other filter.

```{r}
#calculate cpm cutoff around all samples
cpmcutoff <- round(10/min(dge.filt$sample$lib.size/1e+06), digits = 1)
cpmcutoff
#select number of samples meeting that cutoff
nsamplescutoff <- min(table(thca.filt$type))
nsamplescutoff
mask <- rowSums(cpm(dge.filt) > cpmcutoff) >= nsamplescutoff
thca.filt2 <- thca.filt[mask, ]
dge.filt2 <- dge.filt[mask, ]
dim(thca.filt2)
```

```{r exprdist, echo=FALSE, out.width="400px", fig.cap="Fig5. Distribution of average expression level per gene with first filter."}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "",
las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(thca.filt2)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topright", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

Now, we have a dataset of 15408 genes to analyzed.

In this histogram, we have all genes that have passed the cutoff (red bars). However, we observe that the first red columns are not very representative of the group, and as we have a lot of genes to perform the analysis, we are going toapply a second filter. 

To remove them, we choose a cutoff of 3 log2 CPM unit as minimum value of expression and visualize the fitered dataset with another histogram.

```{r}
mask <- avgexp > 3
dim(thca.filt2)
thca.filt3 <- thca.filt[mask, ]
dim(thca.filt3)
dge.filt3 <- dge.filt[mask, ]
dim(dge.filt3)
```

```{r exprdist, echo=FALSE, out.width="400px", fig.cap="Fig6. Distribution of average expression level per gene with second filter."}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "",
las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(thca.filt3)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topright", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

After filtering the dataset with both methods, we have finally 9423 genes to perform a differential expression analysis.

Store un-normalized versions of the filtered expression data.

```{r}
saveRDS(thca.filt3, file.path("./", "thca.filt.unnorm.rds"))
saveRDS(dge.filt3, file.path("./", "dge.filt.unnorm.rds"))
```

## Normalization

We calculate now the normalization factors on the filtered expression data set.

```{r}
dge.filt3 <- calcNormFactors(dge.filt3)
head(dge.filt3$samples$norm.factors)
```

Replace the raw log2 CPM units in the corresponding assay element of the `SummarizedExperiment` object, by the normalized ones.

```{r}
assays(thca.filt3)$logCPM <- cpm(dge.filt3, log=TRUE, normalized.lib.sizes=TRUE, prior.count=0.25)
```

Store normalized versions of the filtered expression data.

```{r}
saveRDS(thca.filt3, file.path("./", "thca.filt.rds"))
saveRDS(dge.filt3, file.path("./", "dge.filt.rds"))
```

## MA-plots

MA plots are used for detecting intensity dependent biases, by comparing two groups of the dataset,

We first examine a global MA-plot for normalized and non-normalized data to have a general idea of the possible dependencies.

```{r maPlotsTumor, fig.height=6, fig.width=6, dpi=100, echo=FALSE, fig.cap="Fig7. MA-plots of normalized and non-normalized data."}
dge$samples$group <- thca$type
table(dge$samples$gorup)
dge.filt3$samples$group <- thca.filt3$type
plotSmear(dge, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
plotSmear(dge.filt3, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
```

In the non-normalized plot, we observe there are a lot of genes non differential expreesion (logFC ~ 0) and also several ones with a a low log2CPM which are removed in the normalized plot to avoid artifacts in the posterior analysis. In the normalized plot, we also observe a smother shape with less outliers. 

We examine now the MA-plots of the normalized expression profiles for each tumor and normal samples sparately, in order to observe if there is any sample with a anomalous expression profile. We look first to
the tumor samples in Figure \@ref(fig:maPlotsTumor).

```{r maPlotsTumor, fig.height=36, fig.width=6, dpi=100, echo=FALSE, fig.cap="Fig8. MA-plots of the tumor samples."}
par(mfrow=c(22, 3), mar=c(4, 5, 3, 1))
setmp <- thca.filt3[, thca.filt3$type == "tumor"]
dgetmp <- dge.filt3[, thca.filt3$type == "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

We do not observe samples with major expression-level dependent biases. Let's
look now to the normal samples in Figure \@ref(fig:maPlotsNormal).

```{r maPlotsNormal, fig.height=18, fig.width=6, dpi=100, echo=FALSE, fig.cap="Fig9. MA-plots of the normal samples."}
par(mfrow=c(9, 3), mar=c(4, 5, 3, 1))
setmp <- thca.filt3[, thca.filt3$type == "normal"]
dgetmp <- dge.filt3[, thca.filt3$type == "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

From normal samples, we can observe there is several with an anomalous profile, so we should remove those samples in order not to have biases in our results

```{r}
#select more samples from tumor and normal
maskbad <- substr(colnames(thca.filt3), 0, 12) %in% c("TCGA.BJ.A28X", "TGCA.EL.A3ZP", "TCGA.ET.A3DP","TCGA.KS.A41I")
dim(thca.filt3)
dim(dge.filt3)
thca.filt4 <- thca.filt3[, !maskbad]
dge.filt4 <- dge.filt3[, !maskbad]
dim(dge.filt4)
dim(thca.filt4)
saveRDS(thca.filt4, file.path("./", "thca.filt4.rds"))
saveRDS(dge.filt4, file.path("./", "dge.filt4.rds"))
```
We remove 4 patients with deviant normal samples, but since for one patient we have a tumor and a normal sample (TCGA.BJ.A28X), we end up with 5 samples less. 

Once, we have done the normalization, we perform a MDS plot (which is a tailored PCA) in order to visualize possibles samples with distinctive features from the rest, which can idicate potential problem with samples.

```{r}
plotMDS(dge.filt4, col = c("red", "blue")[as.integer(dge.filt4$samples$group)], cex = 0.7)
legend("topleft", c("normal", "tumor"), fill = c("red", "blue"), inset = 0.05, cex = 0.7)
```

We can observe two cluster, which indicate a difference between normal and tummor samples. We have to test if this cluster is due to the type tissue or because any batch that confound our interest outcome, in order to continue with further analyses.

Moreover, in normal samples zone we can also observe several tumor samples. If that cluster is because type sample, that can be explained becuse not all thyroid tumors have the same mutations, which produces different levels of severity in cancer patients.


## Batch identification

We will search now for potential surrogate of batch effect indicators. Given that each sample
names corresponds to a TCGA barcode (see https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode),
following the strategy described in http://bioinformatics.mdanderson.org/main/TCGABatchEffects:Overview
we are going to derive different elements of the TCGA barcode and examine their distribution
across samples.

```{r}
tss <- substr(colnames(thca.filt4), 6, 7)
table(tss)
center <- substr(colnames(thca.filt4), 27, 28)
table(center)
plate <- substr(colnames(thca.filt4), 22, 25)
table(plate)
portionanalyte <- substr(colnames(thca.filt4), 18, 20)
table(portionanalyte)
samplevial <- substr(colnames(thca.filt4), 14, 16)
table(samplevial)
```

From this information we can make the following observations:

  * All samples were sequenced at the same center (07)

  * In this dataset, we can find six different combinations of tissue type and vial, it can be a potential batch.

  * Samples were collected across different tissue source sites (TSS).

  * Different samples were sequenced with different plates, so it can be also a potential batch.

  * Most of the samples were sequenced using one portion and analyte combinations, but there is other 5 different portion and analyte combinations

From this data we can consider as possible surrogates of batch effect indicator the tssm, plate, portionanalytic and samplevial.

*TSS*
We are going to use the TSS as surrogate of batch effect indicator. Considering our outcome
of interest as molecular changes between sample types, tumor vs. normal, we will examine now
the cross-classification of this outcome with TSS.

```{r}
table(data.frame(TYPE=thca.filt4$type, TSS=tss))
```

Observe that normal tissues from most of TSS are under-represented with respect to the tumor tissues. If TSS is a source of expression variability, this under-representation in the normal samples may lead to a potential confounding effect.

We examine now how samples group together by hierarchical clustering and multidimensional
scaling, annotating the outcome of interest and the the surrogate of batch indicator. We
calculate again log CPM values with a higher prior count to moderate extreme fold-changes
produced by low counts. The resulting dendrogram is shown in Figure \@ref(fig:sampleClustering).

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
logCPM <- cpm(dge.filt4, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(tss))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt4)
outcome <- paste(substr(colnames(thca.filt4), 9, 12), as.character(thca.filt4$type), sep="-")
names(outcome) <- colnames(thca.filt4)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(tss))), fill=sort(unique(batch)))
```

We can observe there is not evident clustering depending of the tss, so we can descard it as a 
possible batch.

In Figure \@ref(fig:mdsPlot) we show the corresponding MDS plot. Here we see more clearly that the
first source of variation separates tumor from normal samples. We can also observe that two tumor
samples, corresponding to individuals `KL-8404` and `KN-8427` are separated from the rest, just as
it happens in the hierchical clustering. A closer examination of their corresponding MA-plots also
reveals a slight dependence of expression changes on average expression. We may consider discarding
these two samples and doing the MDS plot again to have a closer look to the differences among the rest
of the samples and their relationship with TSS.

*Plate*
```{r}
table(data.frame(TYPE=thca.filt4$type, plate=plate))
```

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S8: Hierarchical clustering of the samples by Plate."}
logCPM <- cpm(dge.filt4, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(plate))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt4)
outcome <- paste(substr(colnames(thca.filt4), 9, 12), as.character(thca.filt4$type), sep="-")
names(outcome) <- colnames(thca.filt4)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(plate))), fill=sort(unique(batch)))
```

*PortionAnalyte*

```{r}
table(data.frame(TYPE=thca.filt4$type, PA=portionanalyte))
```

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S10: Hierarchical clustering of the samples by Portion Analyuc."}
logCPM <- cpm(dge.filt4, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(portionanalyte))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt4)
outcome <- paste(substr(colnames(thca.filt4), 9, 12), as.character(thca.filt4$type), sep="-")
names(outcome) <- colnames(thca.filt4)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(portionanalyte))), fill=sort(unique(batch)))
```


*Samplevial*

```{r}
table(data.frame(TYPE=thca.filt4$type, SV=samplevial))
```

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S12: Hierarchical clustering of the samples by Portion Analyuc."}
logCPM <- cpm(dge.filt4, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(samplevial))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(thca.filt4)
outcome <- paste(substr(colnames(thca.filt4), 9, 12), as.character(thca.filt4$type), sep="-")
names(outcome) <- colnames(thca.filt4)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(samplevial))), fill=sort(unique(batch)))
```

From this hierchical clustering plot, we can observe that there is a different cluster depending 
of the samplevial we use, so they can confounding with the interest outcome we want. For that reason,
we are going to adjust or remove this batch in order to get a non-biased results.

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S11: Multidimensional scaling plot of the samples."}
plotMDS(dge.filt4, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(samplevial))),
       fill=sort(unique(batch)), inset=0.05)
```
REAL BATCH!!!
## Session information

```{r, message=FALSE}
sessionInfo()
```

